// Copyright 2021 Herman Slatman
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// 	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ca

import (
	"context"
	"crypto/rand"
	"crypto/x509"
	"encoding/asn1"
	"fmt"
	"net/http"
	"time"

	"github.com/caddyserver/caddy/v2/modules/caddypki"
	"github.com/globalsign/est"
	"go.uber.org/zap"
)

const (
	defaultCertificateDuration = time.Hour * 24 * 90
)

var (
	oidSubjectAltName = asn1.ObjectIdentifier{2, 5, 29, 17}
)

// CA is responsible for signing certificates requested by clients
// using Enrollment over Secure Transport.
type CA struct {
	pki    *caddypki.CA
	logger *zap.Logger
}

// New creates a new CA for issuing certificates over EST
// backed by a *caddypki.CA instance.
func New(pkiCA *caddypki.CA, logger *zap.Logger) *CA {
	return &CA{
		pki:    pkiCA,
		logger: logger,
	}
}

// CACerts returns the CA root certificate(s) according to RFC7030 4.1.
func (c *CA) CACerts(ctx context.Context, aps string, r *http.Request) ([]*x509.Certificate, error) {

	rootCert := c.pki.RootCertificate()

	// TODO: should we also return intermediate certificates?

	return []*x509.Certificate{rootCert}, nil
}

// CSRAttrs returns CSR attributes requested by this CA
func (c *CA) CSRAttrs(ctx context.Context, aps string, r *http.Request) (est.CSRAttrs, error) {
	attributes := est.CSRAttrs{}

	// TODO: add some requested CSR attributes based on configuration

	return attributes, nil
}

// Enroll requests a new certificate. Also see RFC7030 4.2.
// It will perform several checks and validations
func (c *CA) Enroll(ctx context.Context, csr *x509.CertificateRequest, aps string, r *http.Request) (*x509.Certificate, error) {

	// TODO: check initial authentication?
	// See https://tools.ietf.org/html/rfc7030#section-2.2

	caRoot := c.pki.RootCertificate()
	template, err := generateTemplate(caRoot, csr)
	if err != nil {
		return nil, fmt.Errorf("failed to create template: %w", err)
	}

	key, err := c.pki.RootKey()
	if err != nil {
		return nil, fmt.Errorf("failed to get private key: %w", err)
	}

	// Create and return a new certificate based on the certificate template
	der, err := x509.CreateCertificate(rand.Reader, template, caRoot, csr.PublicKey, key)
	if err != nil {
		return nil, fmt.Errorf("failed to create certificate: %w", err)
	}

	cert, err := x509.ParseCertificate(der)
	if err != nil {
		return nil, fmt.Errorf("failed to parse certificate: %w", err)
	}

	c.logger.Debug(fmt.Sprintf("created certificate: %s", cert.Subject.CommonName))

	// TODO: probably might want to audit this creation + store (metadata of) the cert?

	return cert, nil
}

// Reenroll requests renewal of an existing certificate. Also see RFC7030 4.2.
// Currently it will take all of the information from the certificate and the CSR
// and pass the request on to Enroll(). Validation according to the RFC is
// performed by globalsign/est and we currently do not override the decision
// made in that library. The library will then pass on control by calling
// Reenroll and we again pass it on to Enroll()
func (c *CA) Reenroll(ctx context.Context, cert *x509.Certificate, csr *x509.CertificateRequest, aps string, r *http.Request) (*x509.Certificate, error) {
	// NOTE: validation is already performed by globalsign/est,
	// TODO: a bit more with the existing cert?
	c.logger.Debug(fmt.Sprintf("reenrolling: %s", csr.Subject.CommonName))
	return c.Enroll(ctx, csr, aps, r)
}

// ServerKeyGen requests a new certificate and a private key. In this case
// the private key is thus generated by the server instead of by the client.
// Currently not implemented yet.
func (c *CA) ServerKeyGen(ctx context.Context, csr *x509.CertificateRequest, aps string, r *http.Request) (*x509.Certificate, []byte, error) {
	c.logger.Warn("ServerKeyGen not implemented yet")
	return nil, nil, nil
}

// TPMEnroll to be implemented
func (c *CA) TPMEnroll(ctx context.Context, csr *x509.CertificateRequest, ekcerts []*x509.Certificate, ekPub, akPub []byte, aps string, r *http.Request) ([]byte, []byte, []byte, error) {
	c.logger.Warn("TPMEnroll not implemented yet")
	return nil, nil, nil, nil
}
